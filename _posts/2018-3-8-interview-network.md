---
layout: post
title:  "[实习面试准备] 网络基础"
tag:
- 计算机网络
comments: true
---

近期准备参考[C++ 后台开发面试时一般考察什么？ - Oscarwin的回答 - 知乎](https://www.zhihu.com/question/34574154/answer/253165162)汇总一系列相关基础知识，这一篇是有关网络基础的。

### 如何实现UDP的可靠传输
UDP属于无连接型的协议，相对于TCP而言具有消耗资源少、实时性强的特点，因而许多多媒体数据的实时传输偏爱UDP，即使这样会发生偶尔丢失数据的情况。

如果要实现UDP的可靠传输，就得在应用层上做功夫，模仿TCP实现确认机制、重发机制、窗口机制等。

### TCP三次握手
![](https://controny.github.io/assets/images/posts/20180308151509.png)
**为什么是三次？**  
三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”。假设只有两次握手，考虑下面的情况：

1. 客户端A第一次发送的SYN请求因为网络阻塞而延时了。
2. A重新发生SYN请求。这次服务端B成功收到了请求并进行了回应。
3. 两者的连接结束以后，A第一次发送的SYN请求才终于到达B。B认为这又是一次新的连接请求，于是回应SYN和ACK并进入了连接状态。
4. 但是A压根没有重新请求，因此忽略B发来的回应。
5. 就这样，B还一直等待着A发送数据，造成资源的浪费。

### TCP四次挥手
![](https://controny.github.io/assets/images/posts/20180308154239.png)
MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。  
**为什么需要有长达2MSL的`TIME_WAIT`阶段?** 这主要是为了应对两种情况：

- 若客户端A最后发送的ACK丢失了，则需要等待服务端B重新发送FIN信号。
- 假如A发送的第一个请求连接报文段丢失而未收到确认，A就会重传一次连接请求，后来B收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。假如现在A发送的第一个连接请求报文段没有丢失，而是在某些网络节点长时间都留了，以至于延误到连接释放后的某个时间才到达B，这本来是已失效的报文段，但B并不知道，就会又建立一次连接。而等待的这2MSL就是为了解决这个问题的，A在发送完最后一个确认报后，在经过时间2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### TCP窗口滑动
![](https://controny.github.io/assets/images/posts/20180308194606.png)
TCP的窗口滑动机制实现了**可靠性**和**流量控制**，其原理有如下的特点：

- 发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
- 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。
- 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节是已发送但未确认的状态。
- 接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。
- 接收窗口只会对窗口内最后一个按序到达的字节进行确认（Cumulative ACK）。
